import networkx as nx
import pandas as pd
import os
import sys

# How does this script work briefly
# Reads DOT -> Builds a Digraph -> Prunes the CFG by making a BFS Parse -> Parses the Tree and stores paths -> 
# -> Go through path and decode the listings with the symbolistics

#Function that prints some stats for the graph
def stats_graph(G):
	print("Nr of Nodes: " + str(len(G.nodes)))
	print("Nr of Edges: " + str(len(G.edges)))
	print("Nr of WCC:" + str(sum(1 for _ in nx.weakly_connected_components(G))))
	print("Nr of SCC:" + str(sum(1 for _ in nx.strongly_connected_components(G))))


def parse_sequences(graph_file):

	#Bulding the graph from DOT File
	G = nx.DiGraph(nx.nx_pydot.read_dot(graph_file)) # Parse the DOT file, build a Graph object out of it
	print("Graph Built.")

	#Read the symbol table and data table (exported from Ghidra in CSV format)
	fname = graph_file.split('.')[0] 
	symbols = pd.read_csv('../symbols/{}_symbols.csv'.format(fname))
	data = pd.read_csv('../symbols/{}_data.csv'.format(fname))	
	print("Just read resource files..")


	#Prints Stats
	stats_graph(G)

	#Find entry point and other possible unreachable nodes
	#We go with multiple entries since unreacheable nodes may be entry points for other malware (maybe, talk about buffer overflows), but this can be changed	
	#The entry point of the program can be easily found in the exported DOT file by searching the node with the Symbol='entry' or label='entry'.
	#This might need to be treated later. I go with multiple entries here. 
	entries = []
	for n in G.nodes():
		if G.in_degree(n)==0: #Nodes with an In-Degree of zero may be entries. The entry has an In-Degree of 0
			entries.append(n)
	

	#Generate Trees from the entries. This optimizes the path generation
	#Since it is true that this removes edges and unreachable components it is going to get us sequences faster.
	#Check the problem of generating all simple paths. It is more of a backtracking problem and parsing. 
	#That is why it usually takes time to get all the paths without getting rid of nodes.
	trees = []
	for e in entries:
		T = nx.bfs_tree(G,source=e) 
		trees.append(T)
	

	#For each tree generated from the entries
	for T in trees:
		stats_graph(T) #print stats

		start_point = list(T.nodes())[0] #Get the starting point. The first node should be the entry
		paths = []
		leaves=[]
		sq_nr=0 
		
		#For each node in the tree
		for n in T:
			if T.out_degree(n)==0:
				leaves.append(n) #Save the leaves (which are usually the exit nodes or return nodes)
		
		#For each leaf
		for l in leaves:
			print("For leaf -=" + str(l) + "=- make the paths..") #Print this message
			for p in nx.all_simple_paths(T,start_point,l): #For each possible Path from entry to leaf
				enc="" #Initialize the symbolistic sequence for the path
				
				for n in p: #For each node in the path

					#ENCODING STARTS HERE
					i = list(G.nodes()).index(n) #The index of the node

					# Removes quotes and split by newline. In Ghidra the DOT puts quotes around the code.
					# Is is easier to work without quotes. Also We split by new line and now each token is an instruction
					codestring = (G.nodes[n]['Code'].replace('"','')).split("\n") 
											
					for l in codestring: #For each line/instruction in the codestring
						op = l.split("  ") #Split by spaces
						enc+="N" + str(i) +":"+ op[0] #Encode the instruction
						
						if op[0] =='CALL': #If it's CALL
							
							args = op[1].split(" ",2) # Split again the arguments
							enc+="_"							
							
							
							if len(args)>1 and args[1]=="ptr" and not '+' in args[2]: #Check if it's a CALL that points to a static address
							
								ext_ptr = args[2].strip("[]").replace("0x","") # Extract Address
								
								#Look up for the address in the data file at location. Grab the data(external) from the field	
								#!! There might be errors here. Will look into it another time.						
								ptr_loc = data.loc[data["Location"]==ext_ptr]["Data"].item()
							
								#Look up for the function at location, grab function name (DLL + name)
								callname = symbols.loc[symbols["Location"] == "External[" + ptr_loc + "]"]["Function Name"].item()
								callname = callname.split("::")

								enc+= callname[0] + "_" + callname[1] + "|" # Write the encoded call

							else:
								enc+=op[1]+"|"	#Write the ecnoded
						else:
							enc+="|"
										
					#After we parse the path we write down the encoded sequence
					fl = open("../sequences/{}_{}_sequence_{}.txt".format(fname,start_point,sq_nr),'w')
					fl.write(enc)
					fl.close()
					sq_nr+=1




#TODO careful for referenced by offset or registers Calls. Those with [EPB + address]

#tardir = sys.argv[1]
os.system('mkdir ./graphs')
os.system('mkdir ./sequences')

# Extract CFGs from all samples in the malware samples directory
#os.chdir("./malware")
#fls = os.scandir()
#for f in fls:
#	if f.name.endswith('.exe'):
#		print("Analyse and extract graph {}..".format(f.name))
#		extract_dot(f.name)

#Go to all the CFGs and generate all the sequences
#TODO Optimize. Write sequence in file once it is done.

os.chdir("./graphs") #Change directory
fls = os.scandir() #Scan directory
for f in fls: # For each DOT file
	print("Parsing {}'s graph..".format(f.name))
	parse_sequences(f.name) # Do the thing..
