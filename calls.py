import networkx as nx
import pandas as pd
import os
import sys
import logging
logger = logging.getLogger(__name__) # TO DO: this should be improved in the future to keep the function name
logging.basicConfig(filename='example.log', encoding='utf-8', level=logging.DEBUG)

# How does this script work briefly
# Reads DOT -> Builds a Digraph -> Prunes the CFG by making a BFS Parse -> Parses the Tree and stores paths -> 
# -> Go through path and decode the listings with the symbolistics

#Function that prints some stats for the graph
def stats_graph(G):
	logger.info("Nr of Nodes: " + str(len(G.nodes)))
	logger.info("Nr of Edges: " + str(len(G.edges)))
	logger.info("Nr of WCC:" + str(sum(1 for _ in nx.weakly_connected_components(G))))
	logger.info("Nr of SCC:" + str(sum(1 for _ in nx.strongly_connected_components(G))))

def generate_encoding(CFG, CFG_root, execution_path, defined_data, symbols_table, fname, sequence_count):
	"""
	symbols_table(ro) - Contains the symbol table exported in 
	"""
	enc="" #Initialize the symbolistic sequence for the path
	
	for n in execution_path: #For each node in the path

		#ENCODING STARTS HERE
		i = list(CFG.nodes()).index(n) #The index of the node

		# Removes quotes and split by newline. In Ghidra the DOT puts quotes around the code.
		# Is is easier to work without quotes. Also We split by new line and now each token is an instruction
		logger.info("CFG.nodes[n]['Code'] (" + "type=" + str(type(CFG.nodes[n]['Code'])) + ", value=" + CFG.nodes[n]['Code']+ ")")
		codestring = (CFG.nodes[n]['Code'].replace('"','')).split("\n")

		for l in codestring: #For each line/instruction in the codestring
			op = l.split("  ") #Split by spaces
			enc+="N" + str(i) +":"+ op[0] #Encode the instruction
			
			if op[0] =='CALL': #If it's CALL
				
				# args of form:
				# ['dword', 'ptr', '[0x0040610c]']
				# ['0x00405035']
				args = op[1].split(" ",2) # Split again the arguments
				logger.debug("args" + str(args))
				enc+="_"							
				
				if len(args)>1 and args[1]=="ptr" and not '+' in args[2]: #Check if it's a CALL that points to a static address
				
					ext_ptr = args[2].strip("[]").replace("0x","") # Extract Address
					
					#Look up for the address in the defined_data file at location. Grab the defined_data(external) from the field	
					#!! There might be errors here. Will look into it another time.						
					ptr_loc = defined_data.loc[defined_data["Location"]==ext_ptr]["Data"].item()
				
					#Look up for the function at location, grab function name (DLL + name)
					callname = symbols_table.loc[symbols_table["Location"] == "External[" + ptr_loc + "]"]["Function Name"].item()
					callname = callname.split("::")

					enc+= callname[0] + "_" + callname[1] + "|" # Write the encoded call

				else:
					enc+=op[1]+"|"	#Write the ecnoded
			else:
				enc+="|"
							
		#After we parse the path we write down the encoded sequence
		fl = open("../sequences/{}_{}_sequence_{}.txt".format(fname,CFG_root,sequence_count),'w')
		fl.write(enc)
		fl.close()
		sequence_count+=1
	logger.debug("codestring=" + str(codestring))
	logger.debug("enc=" + enc)
	return sequence_count


def parse_sequences(graph_file):

	#Bulding the graph from DOT File
	CFG = nx.DiGraph(nx.nx_pydot.read_dot(graph_file)) # Parse the DOT file, build a Graph object out of it
	logger.info("Graph Built.")

	#Read the symbol table and defined_data table (exported from Ghidra in CSV format)
	fname = graph_file.split('.')[0] 
	symbols_table = pd.read_csv('../symbols/{}_symbols.csv'.format(fname))
	defined_data = pd.read_csv('../symbols/{}_data.csv'.format(fname))	
	logger.info("Just read resource files..")


	#Prints Stats
	stats_graph(CFG)

	#Find entry point and other possible unreachable nodes
	#We go with multiple entries since unreacheable nodes may be entry points for other malware (maybe, talk about buffer overflows), but this can be changed	
	#The entry point of the program can be easily found in the exported DOT file by searching the node with the Symbol='entry' or label='entry'.
	#This might need to be treated later. I go with multiple entries here. 
	entries = []
	for n in CFG.nodes():
		if CFG.in_degree(n)==0: #Nodes with an In-Degree of zero may be entries. The entry has an In-Degree of 0
			entries.append(n)
			logger.debug("G.out_degree(n)=" + str(CFG.out_degree(n)))
	

	#Generate Trees from the entries. This optimizes the path generation
	#Since it is true that this removes edges and unreachable components it is going to get us sequences faster.
	#Check the problem of generating all simple paths. It is more of a backtracking problem and parsing. 
	#That is why it usually takes time to get all the paths without getting rid of nodes.
	trees = []
	for e in entries:
		T = nx.bfs_tree(CFG,source=e) 
		trees.append(T)
	

	#For each tree generated from the entries
	for T in trees:
		stats_graph(T) #print stats

		CFG_root = list(T.nodes())[0] #Get the starting point. The first node should be the entry
		paths = []
		leaves=[]
		sequence_count=0 
		
		#For each node in the tree
		for n in T:
			if T.out_degree(n)==0:
				leaves.append(n) #Save the leaves (which are usually the exit nodes or return nodes)
		
		#For each leaf
		for l in leaves:
			logger.info("For leaf -=" + str(l) + "=- make the paths..") #Print this message
			for execution_path in nx.all_simple_paths(T,CFG_root,l): #For each possible Path from entry to leaf
				sequence_count = generate_encoding(CFG, CFG_root, execution_path, defined_data, symbols_table, fname, sequence_count)




#TODO careful for referenced by offset or registers Calls. Those with [EPB + address]

#tardir = sys.argv[1]
os.system('mkdir ./graphs')
os.system('mkdir ./sequences')

# Extract CFGs from all samples in the malware samples directory
#os.chdir("./malware")
#fls = os.scandir()
#for f in fls:
#	if f.name.endswith('.exe'):
#		print("Analyse and extract graph {}..".format(f.name))
#		extract_dot(f.name)

#Go to all the CFGs and generate all the sequences
#TODO Optimize. Write sequence in file once it is done.

os.chdir("./graphs") #Change directory
fls = os.scandir() #Scan directory
for f in fls: # For each DOT file
	logger.info("Parsing {}'s graph..".format(f.name))
	parse_sequences(f.name) # Do the thing..
