#Script for building an Interprocedural/Global CodeFlowGraph (ICFG) in Ghidra

import pyghidra, os
import networkx as nx
from networkx.drawing.nx_pydot import write_dot 

#Initialize the headless analyzer
pyghidra.start()

import ghidra
from ghidra.program.model.block import * 
from ghidra.program.model.listing import * 
from ghidra.program.database.code import *
from ghidra.util.task import *

icfg = nx.DiGraph()

with pyghidra.open_program(os.environ['PATH_TO_PROGRAM_TO_ANALYSE']) as flat_api:
    program = flat_api.getCurrentProgram()    
    programListing = program.getListing() 
    monitor = ConsoleTaskMonitor() 
    
    # Use Simple Block to include CALLs for Flow changing instructions
    bm = SimpleBlockModel(program,includeExternals=True) 
    codeBlockIterator = bm.getCodeBlocks(monitor)

    #For each block
    while codeBlockIterator.hasNext(): 
        block = codeBlockIterator.next() 
        addr = str(block.getFirstStartAddress()) #Get start address

        code = ""
        #Extract the block's code
        codeUnit = programListing.getCodeUnits(block,True) #Get the code from the block

        # for each instruction we save it in a string
        while codeUnit.hasNext(): 
            inst = codeUnit.next()

            code += str(inst)
            if codeUnit.hasNext(): code+="\n"

        icfg.add_node('"'+addr+'"',Code=code)

        dest = bm.getDestinations(block,monitor)
        while dest.hasNext():
            d = dest.next()
            daddr = str(d.getDestinationAddress())
            flow = str(d.getFlowType())
                        
            icfg.add_edge('"'+addr+'"','"'+daddr+'"' ,EdgeType=flow)

    write_dot(icfg, os.environ['OUTPUT_DOT_FILE'])