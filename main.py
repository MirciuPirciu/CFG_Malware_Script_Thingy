import os
import sys
import shutil
import logging
import pyghidra
import networkx as nx
from networkx.drawing.nx_pydot import write_dot 

# How does this script work briefly:
#  * Takes a PE executable 
# -> Builds a ICFG using Ghidra -> 
# -> Prunes the ICFG by making a BFS Tree from the entry address block -> 
# -> Parses the Tree DFS and stores the paths -> 
# -> Goes through each path and encodes the listings with the symbolistics


# Initializations (Directory creations, logging)
fname = os.path.basename(os.environ['PATH_TO_PROGRAM_TO_ANALYSE']).split('.')[0] # Get File name
os.chdir(f"{os.environ['OUTPUT_DIRECTORY']}")

if not os.path.exists(f"output_{fname}"):
	os.mkdir(f"output_{fname}")
	os.mkdir(f"output_{fname}/sequences_{fname}")
os.chdir(f"output_{fname}")


logger = logging.getLogger(__name__) # TO DO: this should be improved in the future to keep the function name
logging.basicConfig(filename=f"{fname}.log", encoding='utf-8', level=logging.DEBUG)
logging.getLogger().addHandler(logging.StreamHandler(sys.stdout)) #Log to STDOUT too

#Function that prints some stats for the graph
def stats_graph(G):
	logger.info("Nr of Nodes: " + str(len(G.nodes)))
	logger.info("Nr of Edges: " + str(len(G.edges)))
	logger.info("Nr of WCC:" + str(sum(1 for _ in nx.weakly_connected_components(G))))
	logger.info("Nr of SCC:" + str(sum(1 for _ in nx.strongly_connected_components(G))))

#Extract the entry address from the Portable Executable using Ghidra API
#Inspiration for this function:
#https://gitlab.com/saruman9/ghidra_scripts/-/blob/master/GetEntryPoints.java
def getEntryPointAddress(ghidra_program_object):
		logger.info("Getting Entry Address")
		byteProvider = MemoryByteProvider(ghidra_program_object.getMemory(),ghidra_program_object.getImageBase())
		pe = PortableExecutable(byteProvider, PortableExecutable.SectionLayout.MEMORY)
		optHeader = pe.getNTHeader().getOptionalHeader()
		entry_address = hex(optHeader.getAddressOfEntryPoint() + ghidra_program_object.getImageBase().getOffset()).replace('0x','')
		entry_address = '"'+entry_address.rjust(8,'0')+'"' #Pad from right with 0s
		logger.info("Entry at {}".format(entry_address))
		return entry_address


#Networkx doesn't preserve attributes so we do this procedures for the tree
def construct_tree(cfg,root):
	tree = nx.bfs_tree(cfg,source=root)
	for n in tree.nodes():
		tree.add_node(n,Code=cfg.nodes[n]['Code'])

	logger.info("Dumped Tree..")
	write_dot(tree,f"{fname}_tree.dot")
	return tree

#Function that returns the ICFG, generated by Ghidra, as a networkx's DiGraph object
#Takes as argument a file's path
def gen_icfg(fpath):
	icfg = nx.DiGraph()

	with pyghidra.open_program(fpath,project_name=f"{fname}_ghidra",
					project_location=os.environ['OUTPUT_DIRECTORY'] + f"/output_{fname}") as flat_api: #Analyze the binary file
		program = flat_api.getCurrentProgram()

		if not program.getExecutableFormat() == 'Portable Executable (PE)' : return -1,-1
		programListing = program.getListing() #Get the Listing
		monitor = ConsoleTaskMonitor() #Spawn monitor

		# Use Simple Block to include CALL instructions as Flow instructions in the CFG
		bm = SimpleBlockModel(program)
		codeBlockIterator = bm.getCodeBlocks(monitor)

		#Build a symbol dictionary. We use this to translate external
		#CALL functions from their address to their function name.
		symbols = program.symbolTable.getExternalSymbols()
		external_pointers = dict()

		# Iterate through symbols, build the dictionary.
		# Key: External Linkage Address : Symbol
		for s in symbols:
			external_pointers[str(getExternalLinkageAddresses(program, s.getAddress())[0])] = str(s)

		#Parse all the blocks in the program
		while codeBlockIterator.hasNext(): 
			block = codeBlockIterator.next() 
			addr = str(block.getFirstStartAddress()) #Get start address
			code = "" #We save Code Instructions here

			#Extract the block's code
			codeUnit = programListing.getCodeUnits(block,True) #Get the code from the block

			# Parse each instruction in the block
			while codeUnit.hasNext(): 
				inst = codeUnit.next()

				# Process external CALL instructions
				if inst.getMnemonicString() == 'CALL':
					call_addr = str(inst.getOpObjects(0)[0]) # Get address argument
					if call_addr in external_pointers.keys(): # If the address is external
						inst = "CALL " + external_pointers[call_addr] # Substitute with the func. name
				code += str(inst)
				if codeUnit.hasNext(): code+='\n'

			icfg.add_node('"'+addr+'"',Code=code) # Add node to the ICFG (Note: We add quotes for .dot files)

			#We get the edges for this node by getting the block's destinations
			dest = bm.getDestinations(block,monitor) 

			# We generate the block's edges by its destinations/successors
			while dest.hasNext():
				d = dest.next()
				daddr = str(d.getDestinationAddress()) # Get address for destination
				flow = str(d.getFlowType()) # Get Flow Type

				icfg.add_edge('"'+addr+'"','"'+daddr+'"' ,EdgeType=flow) #Add it to the ICFG

		#Note:Ghidra includes blocks for external functions in their Graphs. 
		#Networkx generated nodes for missing nodes/blocks. 
		#The iterator doesn't usually parse these kind of nodes.
		#They have no attributes set if they are generated. 
		#Here, after building the ICFG, we process the empty generated blocks. 
		#External function blocks would have '?? ??' as the Code attribute.

		#We parse the nodes
		relabel_mapping = {} #Mapping for relabling external nodes
		for n in icfg.nodes:
			if not ('Code' in icfg.nodes[n]): #See which have no Code attribute
				icfg.add_node(n,Code="?? ??") # Update the node with a code attribute
				if 'EXTERNAL' in n: # If it's an external address
					symb = program.symbolTable.getExternalSymbols() 
					# Find which symbol it is, add it to relabel_mapping.
					for s in symb:
						symaddr = str(s.getAddress())
						if n.strip('"') == symaddr : 
							relabel_mapping[n] = '"'+str(s)+'"'
							break

		icfg = nx.relabel_nodes(icfg, relabel_mapping) #Relabel external function nodes

		#Get the Entry Point of the Portable Executable
		entry_address = getEntryPointAddress(program)


		logger.info("ICFG Built..")
		write_dot(icfg, f"{fname}.dot") #Dump the ICFG into a Graphviz DOT File
		return icfg,entry_address

def parse_sequences(fpath):
	logger.info("Building ICFG..")
	cfg,entry = gen_icfg(fpath) # Build the ICFG, get the entry point
	#Check if is PE (inside gen_icfg)
	if cfg == -1 : 
		logger.info('Not PE, skipping...')
		return -1

	#Prints Stats
	stats_graph(cfg)

	#Generate a BFS Tree. This is used to remove cycles
	T = construct_tree(cfg,entry)
	stats_graph(T) # Print stats

	leaves=[]
	sequence_count=0

	#For each node in the tree
	for n in T:
		if T.out_degree(n)==0:
			leaves.append(n) #Save the leaves (which are usually the exit nodes or return nodes)

	#For each leaf
	for l in leaves:
		logger.info("For leaf --=" + str(l) + "=-- make the paths..") #Print this message
		for execution_path in nx.all_simple_paths(T,entry,l): #For each possible Path from entry to a leaf
			sequence_count = generate_encoding(T, entry, execution_path, fname, sequence_count)


def generate_encoding(CFG, CFG_root, execution_path, fname, sequence_count):

	enc="" #Initialize the symbolistic sequence for the path

	for n in execution_path: #For each node in the path

		#ENCODING STARTS HERE
		i = list(CFG.nodes()).index(n) #The index of the node

		# Removes quotes and split by newline. In Ghidra the DOT puts quotes around the code.
		# Is is easier to work without quotes. Also We split by new line and now each token is an instruction

		logger.info("CFG.nodes[n]['Code'] (" + "type=" + str(type(CFG.nodes[n]['Code'])) + ", value=" + CFG.nodes[n]['Code']+ ")")
		codestring = (CFG.nodes[n]['Code'].replace('"','')).split("\n")

		for l in codestring: #For each line/instruction in the codestring
			op = l.split(" ") #Split by spaces
			enc+="N" + str(i) +":"+ op[0] #Encode the instruction

			if op[0] == "??": continue # Skip external blocks, they have no code
			if op[0] =='CALL': #If it's CALL
				enc+= "_" + op[1] + "|" # Write the encoded call
			else:
				enc+="|"

	#After we parse the path we write down the encoded sequence
	fl = open(f"sequences_{fname}/{fname}_sequence_{sequence_count}.txt",'w')
	fl.write(enc)
	fl.close()
	sequence_count+=1
	logger.debug("codestring=" + str(codestring))
	logger.debug("enc=" + enc)
	return sequence_count


if __name__ == '__main__':

	logger.info("Initialzing Headless Analyzer..")
	pyghidra.start() #Initialize the headless analyzer, make sure the env. variable GHIDRA_INSTALL_DIR is set accordingly.

	from ghidra.app.util.bin import ByteProvider
	from ghidra.util.task import ConsoleTaskMonitor
	from ghidra.app.util.bin import MemoryByteProvider
	from ghidra.program.model.block import SimpleBlockModel
	from ghidra.app.util.bin.format.pe import OptionalHeader
	from ghidra.app.util.bin.format.pe import PortableExecutable
	from ghidra.app.nav.NavigationUtils import getExternalLinkageAddresses

	parse_sequences(os.environ['PATH_TO_PROGRAM_TO_ANALYSE']) # Generate the sequences
	shutil.rmtree(f"{fname}_ghidra")
