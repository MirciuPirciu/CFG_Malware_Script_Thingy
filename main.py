import networkx as nx
import os
import sys
import logging
import pyghidra
import shutil
from networkx.drawing.nx_pydot import write_dot 

logger = logging.getLogger(__name__) # TO DO: this should be improved in the future to keep the function name
logging.basicConfig(filename='example.log', encoding='utf-8', level=logging.DEBUG)
logging.getLogger().addHandler(logging.StreamHandler(sys.stdout)) #Log to STDOUT too
# How does this script work briefly:
#  * Takes a PE executable 
# -> Builds a ICFG using Ghidra -> 
# -> Prunes the ICFG by making a BFS Tree from the entry address block -> 
# -> Parses the Tree DFS and stores the paths -> 
# -> Goes through each path and encodes the listings with the symbolistics

#Function that prints some stats for the graph
def stats_graph(G):
	logger.info("Nr of Nodes: " + str(len(G.nodes)))
	logger.info("Nr of Edges: " + str(len(G.edges)))
	logger.info("Nr of WCC:" + str(sum(1 for _ in nx.weakly_connected_components(G))))
	logger.info("Nr of SCC:" + str(sum(1 for _ in nx.strongly_connected_components(G))))

#Function that returns the ICFG, generated by Ghidra, as a networkx's DiGraph object
#Takes as argument a file's name
def gen_icfg(fd):
	icfg = nx.DiGraph() 

	with pyghidra.open_program("./binaries/{}".format(fd)) as flat_api: #Analyze the binary file
		program = flat_api.getCurrentProgram()	
		
		if not program.getExecutableFormat() == 'Portable Executable (PE)' : return -1,-1
		programListing = program.getListing() #Get the Listing
		monitor = ConsoleTaskMonitor() #Spawn monitor
		
		# Use Simple Block to include CALL instructions as Flow instructions in the CFG
		bm = SimpleBlockModel(program) 
		codeBlockIterator = bm.getCodeBlocks(monitor)

		#Build a symbol dictionary. We use this to translate external 
		#CALL functions from their address to their function name.
		symbols = program.symbolTable.getExternalSymbols()
		external_pointers = dict()

		# Iterate through symbols, build the dictionary.
		# Key: External Linkage Address : Symbol
		for s in symbols:
			external_pointers[str(getExternalLinkageAddresses(program, s.getAddress())[0])] = str(s) 

		#Parse all the blocks in the program
		while codeBlockIterator.hasNext(): 
			block = codeBlockIterator.next() 
			addr = str(block.getFirstStartAddress()) #Get start address
			code = "" #We save Code Instructions here

			#Extract the block's code
			codeUnit = programListing.getCodeUnits(block,True) #Get the code from the block

			# Parse each instruction in the block
			while codeUnit.hasNext(): 
				inst = codeUnit.next()

				# Process external CALL instructions
				if inst.getMnemonicString() == 'CALL':
					call_addr = str(inst.getOpObjects(0)[0]) # Get address argument
					if call_addr in external_pointers.keys(): # If the address is external
						inst = "CALL_" + external_pointers[call_addr] # Substitute with the func. name
				code += str(inst)
				if codeUnit.hasNext(): code+='\n'

			icfg.add_node('"'+addr+'"',Code=code) # Add node to the ICFG (Note: We add quotes for .dot files)

			#We get the edges for this node by getting the block's destinations
			dest = bm.getDestinations(block,monitor) 

			# We generate the block's edges by its destinations/successors
			while dest.hasNext():
				d = dest.next()
				daddr = str(d.getDestinationAddress()) # Get address for destination
				flow = str(d.getFlowType()) # Get Flow Type
							
				icfg.add_edge('"'+addr+'"','"'+daddr+'"' ,EdgeType=flow) #Add it to the ICFG

		#Note:Ghidra includes blocks for external functions in their Graphs. 
		#Networkx generated nodes for missing nodes/blocks. 
		#The iterator doesn't usually parse these kind of nodes.
		#They have no attributes set if they are generated. 
		#Here, after building the ICFG, we process the empty generated blocks. 
		#External function blocks would have '?? ??' as the Code attribute.

		#We parse the nodes
		relabel_mapping = {} #Mapping for relabling external nodes
		for n in icfg.nodes:
			if not ('Code' in icfg.nodes[n]): #See which have no Code attribute
				icfg.add_node(n,Code="?? ??") # Update the node with a code attribute
				if 'EXTERNAL' in n: # If it's an external address
					symb = program.symbolTable.getExternalSymbols() 
					# Find which symbol it is, add it to relabel_mapping.
					for s in symb:
						symaddr = str(s.getAddress())
						if n.strip('"') == symaddr : 
							relabel_mapping[n] = '"'+str(s)+'"'
							break

		icfg = nx.relabel_nodes(icfg, relabel_mapping) #Relabel

		#Get the Entry Point of the Portable Executable. Save it inside a global var.
		logger.info("Getting Entry Address")
		byteProvider = MemoryByteProvider(program.getMemory(),program.getImageBase())
		pe = PortableExecutable(byteProvider, PortableExecutable.SectionLayout.MEMORY)
		optHeader = pe.getNTHeader().getOptionalHeader()
		entry_address = hex(optHeader.getAddressOfEntryPoint() + program.getImageBase().getOffset()).replace('x','0')
		entry_address = '"'+entry_address+'"'
		logger.info("Entry at {}".format(entry_address))


		logger.info("ICFG Built..")
		write_dot(icfg, os.environ['OUTPUT_DOT_FILE'].format(program.getName())) #Dump the ICFG into a dot
		return icfg,entry_address

#
def generate_encoding(CFG, CFG_root, execution_path, fname, sequence_count):

	enc="" #Initialize the symbolistic sequence for the path
	
	for n in execution_path: #For each node in the path

		#ENCODING STARTS HERE
		i = list(CFG.nodes()).index(n) #The index of the node

		# Removes quotes and split by newline. In Ghidra the DOT puts quotes around the code.
		# Is is easier to work without quotes. Also We split by new line and now each token is an instruction
		logger.info("CFG.nodes[n]['Code'] (" + "type=" + str(type(CFG.nodes[n]['Code'])) + ", value=" + CFG.nodes[n]['Code']+ ")")
		codestring = (CFG.nodes[n]['Code'].replace('"','')).split("\n")

		for l in codestring: #For each line/instruction in the codestring
			op = l.split(" ") #Split by spaces
			enc+="N" + str(i) +":"+ op[0] #Encode the instruction
			
			if op[0] =='CALL': #If it's CALL
				enc+= op[1] + "|" # Write the encoded call
			else:
				enc+="|"
							
		#After we parse the path we write down the encoded sequence	
		fl = open("./sequences/{}/{}_{}_sequence_{}.txt".format(fname,fname,CFG_root,sequence_count),'w')
		fl.write(enc)
		fl.close()
		sequence_count+=1
	logger.debug("codestring=" + str(codestring))
	logger.debug("enc=" + enc)
	return sequence_count


def parse_sequences(fname):
	logger.info("Building ICFG..")
	cfg,entry = gen_icfg(fname) # Build the ICFG

	if cfg == -1 :
		logger.info('Not PE, skipping...')
		return -1

	#Prints Stats
	stats_graph(cfg)

	#Generate a BFS Tree. This is used to remove cycles 	
	T = nx.bfs_tree(cfg,source=entry)
	stats_graph(T) # Print stats

	leaves=[]
	sequence_count=0 
	
	#For each node in the tree
	for n in T:
		if T.out_degree(n)==0:
			leaves.append(n) #Save the leaves (which are usually the exit nodes or return nodes)
		
	#For each leaf
	for l in leaves:
		logger.info("For leaf -=" + str(l) + "=- make the paths..") #Print this message
		for execution_path in nx.all_simple_paths(T,entry,l): #For each possible Path from entry to leaf
			sequence_count = generate_encoding(cfg, entry, execution_path, fname, sequence_count)

if __name__ == '__main__':
	logger.info("Initialzing Headless Analyzer..")
	pyghidra.start() #Initialize the headless analyzer, make sure the env. variable GHIDRA_INSTALL_DIR is set accordingly.

	from ghidra.app.nav.NavigationUtils import *
	from ghidra.program.model.listing import * 
	from ghidra.program.database.code import *
	from ghidra.program.model.block import * 
	from ghidra.util.task import *
	from ghidra.base.project import *
	from ghidra.app.util.bin import ByteProvider
	from ghidra.app.util.bin import MemoryByteProvider
	from ghidra.app.util.bin.format.pe import OptionalHeader
	from ghidra.app.util.bin.format.pe import PortableExecutable
	os.system('mkdir ./sequences')

	fls = os.scandir('./binaries') #Scan directory
	for f in fls: # For each DOT file
		os.system('mkdir ./sequences/{}'.format(f.name))	
		logger.info(">>> Executing on {}..".format(f.name))
		parse_sequences(f.name) # Generate the sequences